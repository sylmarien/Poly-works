Lors de ce TP, nous avons pu mettre en pratique certains éléments vus lors des cours, dont le premier est celui de l'usage des VAOs et VBOs.
Nous avons utilisé deux VAOs pour dessiner les plans limitant l'espace accessible aux particules pour l'un et les particules elles-mêmes pour l'autre, optimisant de ce fait l'affichage en tirant profit des optimisations internes d'OpenGL lors du chargement de l'un et l'autre comparé à des chargements de VBOs dans un unique VBO.
Dans ce second VAO, nous avons fait le choix d'utiliser l'option \textit{GL\_STREAM\_DRAW} dans la fonction \textit{glBufferData} pour le VBO contenant les informations sur les particules.
En effet, les données dans ce VBO ne sont utilisées qu'une seule fois avant d'être écrasées, rendant ce choix d'option particulièrement adapté à la situation.

De son côté, la fonction d'initialisation des particules \textit{initPart} génère des valeurs initiales pour la direction et la valeur de la vitesse initiale, la couleur d'affichage et la durée de vie d'une particule tout en la plaçant au puits.
Nous l'utilisons donc en particulier pour l'initialisation et la ré-initialisation des particules pour mettre en place le comportement demandé par les exigences.

Concernant la représentation de la gravité, la modélisation que nous utilisons nous permet d'avoir une représentation très basique du phénomène de la collision par choc rigide et l'ajout de la force gravitationnelle selon la composante des z donne bien une trajectoire parabolique aux particules.
Mais dans l'implémentation initial (voir~\ref{sec:mouvement}), la collision est détectée lorsqu'une particule est déjà sortie du volume dans lequel elle est censée être contrainte.
Une fois cette situation détectée on inverse simplement sa vitesse après l'avoir actualisée ce qui permet d'assurer le retour de la particule dans le volume lors de la prochaine itération.
Cependant, cela n'est pas toujours le cas lorsque l'on s'intéresse aux collisions avec la paroi supérieure de l'espace considéré.
En effet, comme on actualise la vitesse avant de l'inverser, il existe un cas où la nouvelle vitesse de la particule ainsi obtenue n'est pas suffisante pour retraverser la paroi à la prochaine itération.
La particule est alors bloquée à l'extérieur du volume, s'en éloignant progressivement, jusqu'à sa fin de vie, sa vitesse s'inversant de sens à chaque itération mais en ayant toujours une norme plus grande lors de l'éloignement de la surface que lors de son rapprochement.
Notre représentation des collisions est donc imparfaite tant parce qu'elle laisse les particules traverser les surfaces avant de les "renvoyer dans le volume" (voir figure~\ref{fig:depassement}) que parce qu'elle présente un effet de bord laissant certaines particules "s'échapper" du volume (voir figure~\ref{fig:echappement}).
C'est pourquoi l'une des améliorations qui pourrait être faite à ce niveau est de mieux prendre en compte le choc rigide, en faisant en sorte que la particule ne dépasse pas les limites de l'univers, nous pourrions par exemple les faire s'arrêter au niveau du plan, cela entraînerait une sorte de compression des vitesses à proximité des parois, ou calculer la position suivant la collision mais dans ce cas aussi, nous aurions une sorte de trajectoire étrange pour la particule qui semblerait rebondir avant le bord de l'univers, même si cette sensation pourrait en fait être masquée par les dimensions des particules s'étendant au-delà du point considéré pour représenter leur position.
De plus, cela se ferait au prix de davantage d'opérations à effectuer pour traiter le cas des collisions : ce que l'on gagnerait en précision et justesse serait alors perdu en performance et donc en capacité maximal de particules que pourrait supporter le programme.

Lors de la représentation des particules sous formes de lutin, on utilise dans un premier temps le nuanceur de géométrie pour dessiner un carré autour du point de coordonnée de chaque particule dont la face avant se retrouve toujours en face de l'observateur.
C'est sur ce carré que, après avoir chargé et transmis au nuanceur de fragment la texture souhaitée, nous interpolons la couleur en fonction de la texture appliquée et de la couleur de la particule puis supprimons les parties dont la somme des couleurs est inférieure à un seuil de 1.
Cela correspond aux zones les plus sombres, et donne donc aux particules la forme voulue, le noir dans la texture correspondant à "l'extérieur de la forme".
Cette approche permet de donner une impression de 3D aux particules de façon peu coûteuse, mais donne une illusion relativement faible que l'on met facilement en évidence en observant plus attentivement le rendu. Une amélioration du rendu, au prix d'un coût en performance, serait d'utiliser la tesselation comme vue en cours afin de dessiner un volume autour des particules au lieu d'un plan et d'y appliquer ensuite une texture plus complexe sur toute la surface ainsi créée.
Le résultat serait alors bien plus convaincant mais le nombre de particules maximal devrait certainement être revu à la baisse puisque le nombre de points à manipuler pour chacune d'elles deviendrait bien plus important que les 4 coins du carré actuel.

Comme décrit dans la partie précédente, chaque particule se voit attribuer une couleur unique, qui n'est pas affichée, afin de permettre la sélection. Le nombre maximal de \begin{math}2^24\end{math} particules distinctes possibles avec notre méthode est largement suffisant puisque bien supérieur aux nombre maximum de 100 000 particules prévu dans le TP et même bien supérieur à la capacité d'affichage de nos machines, le programme n'étant déjà plus fluide avec 1 000 000 de particules.
Lors d'un clic à l'écran sur une particule, nous la retrouvons parmi toutes les autres particules créées grâce à cet identifiant unique, la marquons comme sélectionnée (à l'aide de sa variable d'état \textit{estSelectionne}) et l'affichons alors en noir.
Toutes les particules sélectionnées peuvent alors être réinitialisées, en utilisant la touche \textit{p}, grâce à la fonction \textit{ramenerSelectionnes} qui se charge de parcourir l'ensemble des particules, et de réinitialiser chaque particule dont l'état \textit{estSelectionnee} est vrai.
Cette solution répond aux exigences du TP et est suffisamment efficace dans son cadre, mais il est possible que la tenue d'une table des particules sélectionnées puisse permettre une optimisation du programme, notamment lorsqu'on considère le cas d'un grand nombre de particules, puisque cela permettrait d'éviter certains des parcours de l'ensemble des particules existantes, en particulier lors de leur ré-initialisation.